// This file is part of nand2tetris, as taught in The Hebrew University, and
// was written by Aviv Yaish. It is an extension to the specifications given
// [here](https://www.nand2tetris.org) (Shimon Schocken and Noam Nisan, 2017),
// as allowed by the Creative Common Attribution-NonCommercial-ShareAlike 3.0
// Unported [License](https://creativecommons.org/licenses/by-nc-sa/3.0/).

// The ExtendAlu chip is an extension of the standard ALU which also supports
// shift operations.
// The inputs of the extended ALU are instruction[9], x[16], y[16].
// The "ng" and "zr" output pins behave the same as in the regular ALU.
// The "out" output is defined as follows:
// If instruction[8]=1 and instruction[7]=1 the output is identical to the
// regular ALU, where:
// instruction[5]=zx, instruction[4]=nx, ..., instruction[0]=no
// Else, if instruction[8]=0 and instruction[7]=1, the output is a shift:
// - If instruction[4] == 0, the input "y" will be shifted, otherwise "x".
// - If instruction[5] == 0, the shift will be a right-shift, otherwise left.
// - All other inputs are undefined.

CHIP ExtendAlu {
    IN x[16], y[16], instruction[9];
    OUT out[16], zr, ng;

    PARTS:
    // Shift?
    Not(in=instruction[8], out=notInst8);
    And(a=notInst8, b=instruction[7], out=shift);

    // ALU
    ALU(
        x=x,
        y=y,
        zx=instruction[5],
        nx=instruction[4],
        zy=instruction[3],
        ny=instruction[2],
        f=instruction[1],
        no=instruction[0],
        out=aluOut,
        zr=aluZr,
        ng=aluNg
    );

    // Shift logic
    // Select which input to shift (y or x)
    Mux16(a=y, b=x, sel=instruction[4], out=shiftInput);

    // Perform the shift
    ShiftLeft(in=shiftInput, out=leftShifted);
    ShiftRight(in=shiftInput, out=rightShifted);

    // Select shift direction
    Mux16(a=rightShifted, b=leftShifted, sel=instruction[5], out=shiftOut);

    // Calculate zr
    Or16(a=shiftOut, b=false, out[0..7]=shiftLow, out[8..15]=shiftHigh, out[15]=shiftSign);
    Or8Way(in=shiftLow, out=or1);
    Or8Way(in=shiftHigh, out=or2);
    Or(a=or1, b=or2, out=Notzr);
    Not(in=Notzr, out=shiftZr);

    // Select final outputs
    Mux16(a=aluOut, b=shiftOut, sel=shift, out=out);
    Mux(a=aluZr, b=shiftZr, sel=shift, out=zr);
    Mux(a=aluNg, b=shiftSign, sel=shift, out=ng);
}