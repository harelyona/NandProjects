// Bootstrap the program:
@256
D=A
@SP
M=D
// call Sys.init:
@$ret.1
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@5
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Sys.init
0;JMP
($ret.1)
// funciton Math.init:
(Math.init)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 16:
@16
D=A
@SP
A=M
M=D
@SP
M=M+1
// call Array.new:
@Math.init$ret.2
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Array.new
0;JMP
(Math.init$ret.2)
// C_POP static 1:
@Math.1
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 16:
@16
D=A
@SP
A=M
M=D
@SP
M=M+1
// call Array.new:
@Math.init$ret.3
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Array.new
0;JMP
(Math.init$ret.3)
// C_POP static 0:
@Math.0
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label WHILE_EXP0:
(Math.init$WHILE_EXP0)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 15:
@15
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE1
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE1
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL1
D;JLT
@R15
M=0
@END_BOOL1
0;JMP
(X_NEGATIVE_Y_POSITIVE1)
@R15
M=-1
@END_BOOL1
0;JMP
(Y_NEGATIVE1)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE1
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL1
0;JMP
(X_AND_Y_NEGATIVE1)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL1
D;JLT
@R15
M=0
@END_BOOL1
0;JMP
(END_BOOL1)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Math.init$WHILE_END0
D;JNE
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto WHILE_EXP0:
@Math.init$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Math.init$WHILE_END0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// return Math.init:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Math.abs:
(Math.abs)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE2
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE2
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL2
D;JLT
@R15
M=0
@END_BOOL2
0;JMP
(X_NEGATIVE_Y_POSITIVE2)
@R15
M=-1
@END_BOOL2
0;JMP
(Y_NEGATIVE2)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE2
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL2
0;JMP
(X_AND_Y_NEGATIVE2)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL2
D;JLT
@R15
M=0
@END_BOOL2
0;JMP
(END_BOOL2)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Math.abs$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Math.abs$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Math.abs$IF_TRUE0)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// neg
@SP
A=M-1
M=-M
// C_POP argument 0:
@ARG
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Math.abs$IF_FALSE0)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// return Math.abs:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Math.multiply:
(Math.multiply)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE3
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE3
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL3
D;JLT
@R15
M=0
@END_BOOL3
0;JMP
(X_NEGATIVE_Y_POSITIVE3)
@R15
M=-1
@END_BOOL3
0;JMP
(Y_NEGATIVE3)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE3
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL3
0;JMP
(X_AND_Y_NEGATIVE3)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL3
D;JLT
@R15
M=0
@END_BOOL3
0;JMP
(END_BOOL3)
@R15
D=M
@SP
A=M-1
M=D
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE4
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE4
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL4
D;JGT
@R15
M=0
@END_BOOL4
0;JMP
(X_NEGATIVE_Y_POSITIVE4)
@R15
M=0
@END_BOOL4
0;JMP
(Y_NEGATIVE4)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE4
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL4
0;JMP
(X_AND_Y_NEGATIVE4)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL4
D;JGT
@R15
M=0
@END_BOOL4
0;JMP
(END_BOOL4)
@R15
D=M
@SP
A=M-1
M=D
// and
@SP
AM=M-1
D=M
A=A-1
M=M&D
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE5
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE5
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL5
D;JGT
@R15
M=0
@END_BOOL5
0;JMP
(X_NEGATIVE_Y_POSITIVE5)
@R15
M=0
@END_BOOL5
0;JMP
(Y_NEGATIVE5)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE5
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL5
0;JMP
(X_AND_Y_NEGATIVE5)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL5
D;JGT
@R15
M=0
@END_BOOL5
0;JMP
(END_BOOL5)
@R15
D=M
@SP
A=M-1
M=D
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE6
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE6
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL6
D;JLT
@R15
M=0
@END_BOOL6
0;JMP
(X_NEGATIVE_Y_POSITIVE6)
@R15
M=-1
@END_BOOL6
0;JMP
(Y_NEGATIVE6)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE6
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL6
0;JMP
(X_AND_Y_NEGATIVE6)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL6
D;JLT
@R15
M=0
@END_BOOL6
0;JMP
(END_BOOL6)
@R15
D=M
@SP
A=M-1
M=D
// and
@SP
AM=M-1
D=M
A=A-1
M=M&D
// or
@SP
AM=M-1
D=M
A=A-1
M=M|D
// C_POP local 4:
@LCL
D=M
@4
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.abs:
@Math.multiply$ret.4
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.abs
0;JMP
(Math.multiply$ret.4)
// C_POP argument 0:
@ARG
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.abs:
@Math.multiply$ret.5
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.abs
0;JMP
(Math.multiply$ret.5)
// C_POP argument 1:
@ARG
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE7
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE7
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL7
D;JLT
@R15
M=0
@END_BOOL7
0;JMP
(X_NEGATIVE_Y_POSITIVE7)
@R15
M=-1
@END_BOOL7
0;JMP
(Y_NEGATIVE7)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE7
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL7
0;JMP
(X_AND_Y_NEGATIVE7)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL7
D;JLT
@R15
M=0
@END_BOOL7
0;JMP
(END_BOOL7)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Math.multiply$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Math.multiply$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Math.multiply$IF_TRUE0)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 1:
@LCL
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP argument 0:
@ARG
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP argument 1:
@ARG
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Math.multiply$IF_FALSE0)
// label WHILE_EXP0:
(Math.multiply$WHILE_EXP0)
// C_PUSH local 2:
@LCL
D=M
@2
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE8
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE8
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL8
D;JLT
@R15
M=0
@END_BOOL8
0;JMP
(X_NEGATIVE_Y_POSITIVE8)
@R15
M=-1
@END_BOOL8
0;JMP
(Y_NEGATIVE8)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE8
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL8
0;JMP
(X_AND_Y_NEGATIVE8)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL8
D;JLT
@R15
M=0
@END_BOOL8
0;JMP
(END_BOOL8)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Math.multiply$WHILE_END0
D;JNE
// C_PUSH local 3:
@LCL
D=M
@3
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// and
@SP
AM=M-1
D=M
A=A-1
M=M&D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE9
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE9
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL9
D;JGT
@R15
M=0
@END_BOOL9
0;JMP
(X_NEGATIVE_Y_POSITIVE9)
@R15
M=0
@END_BOOL9
0;JMP
(Y_NEGATIVE9)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE9
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL9
0;JMP
(X_AND_Y_NEGATIVE9)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL9
D;JGT
@R15
M=0
@END_BOOL9
0;JMP
(END_BOOL9)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE1:
@SP
AM=M-1
D=M
@Math.multiply$IF_TRUE1
D;JNE
// goto IF_FALSE1:
@Math.multiply$IF_FALSE1
0;JMP
// label IF_TRUE1:
(Math.multiply$IF_TRUE1)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 2:
@LCL
D=M
@2
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 3:
@LCL
D=M
@3
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 2:
@LCL
D=M
@2
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE1:
(Math.multiply$IF_FALSE1)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP argument 0:
@ARG
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 3:
@LCL
D=M
@3
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 3:
@LCL
D=M
@3
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto WHILE_EXP0:
@Math.multiply$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Math.multiply$WHILE_END0)
// C_PUSH local 4:
@LCL
D=M
@4
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// if goto IF_TRUE2:
@SP
AM=M-1
D=M
@Math.multiply$IF_TRUE2
D;JNE
// goto IF_FALSE2:
@Math.multiply$IF_FALSE2
0;JMP
// label IF_TRUE2:
(Math.multiply$IF_TRUE2)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// neg
@SP
A=M-1
M=-M
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE2:
(Math.multiply$IF_FALSE2)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// return Math.multiply:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Math.divide:
(Math.divide)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// eq
@SP
AM=M-1
D=M
A=A-1
D=M-D
M=0
@NOT_EQUAL10
D;JNE
// Handle the equal case by setting -1 (true)
@SP
A=M-1
M=-1
(NOT_EQUAL10)
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Math.divide$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Math.divide$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Math.divide$IF_TRUE0)
// C_PUSH constant 3:
@3
D=A
@SP
A=M
M=D
@SP
M=M+1
// call Sys.error:
@Math.divide$ret.6
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Sys.error
0;JMP
(Math.divide$ret.6)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Math.divide$IF_FALSE0)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE11
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE11
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL11
D;JLT
@R15
M=0
@END_BOOL11
0;JMP
(X_NEGATIVE_Y_POSITIVE11)
@R15
M=-1
@END_BOOL11
0;JMP
(Y_NEGATIVE11)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE11
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL11
0;JMP
(X_AND_Y_NEGATIVE11)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL11
D;JLT
@R15
M=0
@END_BOOL11
0;JMP
(END_BOOL11)
@R15
D=M
@SP
A=M-1
M=D
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE12
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE12
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL12
D;JGT
@R15
M=0
@END_BOOL12
0;JMP
(X_NEGATIVE_Y_POSITIVE12)
@R15
M=0
@END_BOOL12
0;JMP
(Y_NEGATIVE12)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE12
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL12
0;JMP
(X_AND_Y_NEGATIVE12)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL12
D;JGT
@R15
M=0
@END_BOOL12
0;JMP
(END_BOOL12)
@R15
D=M
@SP
A=M-1
M=D
// and
@SP
AM=M-1
D=M
A=A-1
M=M&D
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE13
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE13
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL13
D;JGT
@R15
M=0
@END_BOOL13
0;JMP
(X_NEGATIVE_Y_POSITIVE13)
@R15
M=0
@END_BOOL13
0;JMP
(Y_NEGATIVE13)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE13
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL13
0;JMP
(X_AND_Y_NEGATIVE13)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL13
D;JGT
@R15
M=0
@END_BOOL13
0;JMP
(END_BOOL13)
@R15
D=M
@SP
A=M-1
M=D
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE14
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE14
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL14
D;JLT
@R15
M=0
@END_BOOL14
0;JMP
(X_NEGATIVE_Y_POSITIVE14)
@R15
M=-1
@END_BOOL14
0;JMP
(Y_NEGATIVE14)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE14
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL14
0;JMP
(X_AND_Y_NEGATIVE14)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL14
D;JLT
@R15
M=0
@END_BOOL14
0;JMP
(END_BOOL14)
@R15
D=M
@SP
A=M-1
M=D
// and
@SP
AM=M-1
D=M
A=A-1
M=M&D
// or
@SP
AM=M-1
D=M
A=A-1
M=M|D
// C_POP local 2:
@LCL
D=M
@2
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.abs:
@Math.divide$ret.7
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.abs
0;JMP
(Math.divide$ret.7)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.abs:
@Math.divide$ret.8
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.abs
0;JMP
(Math.divide$ret.8)
// C_POP argument 0:
@ARG
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label WHILE_EXP0:
(Math.divide$WHILE_EXP0)
// C_PUSH local 3:
@LCL
D=M
@3
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// not
@SP
A=M-1
M=!M
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Math.divide$WHILE_END0
D;JNE
// C_PUSH constant 32767:
@32767
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE15
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE15
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL15
D;JLT
@R15
M=0
@END_BOOL15
0;JMP
(X_NEGATIVE_Y_POSITIVE15)
@R15
M=-1
@END_BOOL15
0;JMP
(Y_NEGATIVE15)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE15
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL15
0;JMP
(X_AND_Y_NEGATIVE15)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL15
D;JLT
@R15
M=0
@END_BOOL15
0;JMP
(END_BOOL15)
@R15
D=M
@SP
A=M-1
M=D
// C_POP local 3:
@LCL
D=M
@3
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 3:
@LCL
D=M
@3
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// not
@SP
A=M-1
M=!M
// if goto IF_TRUE1:
@SP
AM=M-1
D=M
@Math.divide$IF_TRUE1
D;JNE
// goto IF_FALSE1:
@Math.divide$IF_FALSE1
0;JMP
// label IF_TRUE1:
(Math.divide$IF_TRUE1)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE16
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE16
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL16
D;JGT
@R15
M=0
@END_BOOL16
0;JMP
(X_NEGATIVE_Y_POSITIVE16)
@R15
M=0
@END_BOOL16
0;JMP
(Y_NEGATIVE16)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE16
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL16
0;JMP
(X_AND_Y_NEGATIVE16)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL16
D;JGT
@R15
M=0
@END_BOOL16
0;JMP
(END_BOOL16)
@R15
D=M
@SP
A=M-1
M=D
// C_POP local 3:
@LCL
D=M
@3
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 3:
@LCL
D=M
@3
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// not
@SP
A=M-1
M=!M
// if goto IF_TRUE2:
@SP
AM=M-1
D=M
@Math.divide$IF_TRUE2
D;JNE
// goto IF_FALSE2:
@Math.divide$IF_FALSE2
0;JMP
// label IF_TRUE2:
(Math.divide$IF_TRUE2)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE2:
(Math.divide$IF_FALSE2)
// label IF_FALSE1:
(Math.divide$IF_FALSE1)
// goto WHILE_EXP0:
@Math.divide$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Math.divide$WHILE_END0)
// label WHILE_EXP1:
(Math.divide$WHILE_EXP1)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// neg
@SP
A=M-1
M=-M
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE17
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE17
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL17
D;JGT
@R15
M=0
@END_BOOL17
0;JMP
(X_NEGATIVE_Y_POSITIVE17)
@R15
M=0
@END_BOOL17
0;JMP
(Y_NEGATIVE17)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE17
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL17
0;JMP
(X_AND_Y_NEGATIVE17)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL17
D;JGT
@R15
M=0
@END_BOOL17
0;JMP
(END_BOOL17)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto WHILE_END1:
@SP
AM=M-1
D=M
@Math.divide$WHILE_END1
D;JNE
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE18
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE18
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL18
D;JGT
@R15
M=0
@END_BOOL18
0;JMP
(X_NEGATIVE_Y_POSITIVE18)
@R15
M=0
@END_BOOL18
0;JMP
(Y_NEGATIVE18)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE18
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL18
0;JMP
(X_AND_Y_NEGATIVE18)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL18
D;JGT
@R15
M=0
@END_BOOL18
0;JMP
(END_BOOL18)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto IF_TRUE3:
@SP
AM=M-1
D=M
@Math.divide$IF_TRUE3
D;JNE
// goto IF_FALSE3:
@Math.divide$IF_FALSE3
0;JMP
// label IF_TRUE3:
(Math.divide$IF_TRUE3)
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 1:
@LCL
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 1:
@Math.1
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_POP argument 0:
@ARG
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE3:
(Math.divide$IF_FALSE3)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto WHILE_EXP1:
@Math.divide$WHILE_EXP1
0;JMP
// label WHILE_END1:
(Math.divide$WHILE_END1)
// C_PUSH local 2:
@LCL
D=M
@2
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// if goto IF_TRUE4:
@SP
AM=M-1
D=M
@Math.divide$IF_TRUE4
D;JNE
// goto IF_FALSE4:
@Math.divide$IF_FALSE4
0;JMP
// label IF_TRUE4:
(Math.divide$IF_TRUE4)
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// neg
@SP
A=M-1
M=-M
// C_POP local 1:
@LCL
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE4:
(Math.divide$IF_FALSE4)
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// return Math.divide:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Math.sqrt:
(Math.sqrt)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE19
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE19
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL19
D;JLT
@R15
M=0
@END_BOOL19
0;JMP
(X_NEGATIVE_Y_POSITIVE19)
@R15
M=-1
@END_BOOL19
0;JMP
(Y_NEGATIVE19)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE19
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL19
0;JMP
(X_AND_Y_NEGATIVE19)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL19
D;JLT
@R15
M=0
@END_BOOL19
0;JMP
(END_BOOL19)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Math.sqrt$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Math.sqrt$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Math.sqrt$IF_TRUE0)
// C_PUSH constant 4:
@4
D=A
@SP
A=M
M=D
@SP
M=M+1
// call Sys.error:
@Math.sqrt$ret.9
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Sys.error
0;JMP
(Math.sqrt$ret.9)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Math.sqrt$IF_FALSE0)
// C_PUSH constant 7:
@7
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label WHILE_EXP0:
(Math.sqrt$WHILE_EXP0)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// neg
@SP
A=M-1
M=-M
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE20
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE20
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL20
D;JGT
@R15
M=0
@END_BOOL20
0;JMP
(X_NEGATIVE_Y_POSITIVE20)
@R15
M=0
@END_BOOL20
0;JMP
(Y_NEGATIVE20)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE20
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL20
0;JMP
(X_AND_Y_NEGATIVE20)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL20
D;JGT
@R15
M=0
@END_BOOL20
0;JMP
(END_BOOL20)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Math.sqrt$WHILE_END0
D;JNE
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// call Math.multiply:
@Math.sqrt$ret.10
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.multiply
0;JMP
(Math.sqrt$ret.10)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE21
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE21
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL21
D;JGT
@R15
M=0
@END_BOOL21
0;JMP
(X_NEGATIVE_Y_POSITIVE21)
@R15
M=0
@END_BOOL21
0;JMP
(Y_NEGATIVE21)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE21
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL21
0;JMP
(X_AND_Y_NEGATIVE21)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL21
D;JGT
@R15
M=0
@END_BOOL21
0;JMP
(END_BOOL21)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto IF_TRUE1:
@SP
AM=M-1
D=M
@Math.sqrt$IF_TRUE1
D;JNE
// goto IF_FALSE1:
@Math.sqrt$IF_FALSE1
0;JMP
// label IF_TRUE1:
(Math.sqrt$IF_TRUE1)
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Math.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 1:
@LCL
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE1:
(Math.sqrt$IF_FALSE1)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto WHILE_EXP0:
@Math.sqrt$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Math.sqrt$WHILE_END0)
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// return Math.sqrt:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Math.max:
(Math.max)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE22
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE22
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL22
D;JGT
@R15
M=0
@END_BOOL22
0;JMP
(X_NEGATIVE_Y_POSITIVE22)
@R15
M=0
@END_BOOL22
0;JMP
(Y_NEGATIVE22)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE22
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL22
0;JMP
(X_AND_Y_NEGATIVE22)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL22
D;JGT
@R15
M=0
@END_BOOL22
0;JMP
(END_BOOL22)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Math.max$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Math.max$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Math.max$IF_TRUE0)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP argument 1:
@ARG
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Math.max$IF_FALSE0)
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// return Math.max:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Math.min:
(Math.min)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE23
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE23
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL23
D;JLT
@R15
M=0
@END_BOOL23
0;JMP
(X_NEGATIVE_Y_POSITIVE23)
@R15
M=-1
@END_BOOL23
0;JMP
(Y_NEGATIVE23)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE23
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL23
0;JMP
(X_AND_Y_NEGATIVE23)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL23
D;JLT
@R15
M=0
@END_BOOL23
0;JMP
(END_BOOL23)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Math.min$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Math.min$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Math.min$IF_TRUE0)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP argument 1:
@ARG
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Math.min$IF_FALSE0)
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// return Math.min:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Array.new:
(Array.new)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE24
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE24
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL24
D;JGT
@R15
M=0
@END_BOOL24
0;JMP
(X_NEGATIVE_Y_POSITIVE24)
@R15
M=0
@END_BOOL24
0;JMP
(Y_NEGATIVE24)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE24
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL24
0;JMP
(X_AND_Y_NEGATIVE24)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL24
D;JGT
@R15
M=0
@END_BOOL24
0;JMP
(END_BOOL24)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Array.new$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Array.new$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Array.new$IF_TRUE0)
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// call Sys.error:
@Array.new$ret.1
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Sys.error
0;JMP
(Array.new$ret.1)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Array.new$IF_FALSE0)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Memory.alloc:
@Array.new$ret.2
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Memory.alloc
0;JMP
(Array.new$ret.2)
// return Array.new:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Array.dispose:
(Array.dispose)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP pointer 0:
@THIS
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH pointer 0:
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Memory.deAlloc:
@Array.dispose$ret.3
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Memory.deAlloc
0;JMP
(Array.dispose$ret.3)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// return Array.dispose:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Main.main:
(Main.main)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 1:
@LCL
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 3:
@3
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 2:
@LCL
D=M
@2
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 4:
@4
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 3:
@LCL
D=M
@3
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 5:
@5
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 4:
@LCL
D=M
@4
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 6:
@6
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 5:
@LCL
D=M
@5
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 2:
@LCL
D=M
@2
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 3:
@LCL
D=M
@3
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 4:
@LCL
D=M
@4
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 5:
@LCL
D=M
@5
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 6:
@LCL
D=M
@6
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.multiply:
@Main.main$ret.1
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.multiply
0;JMP
(Main.main$ret.1)
// C_PUSH local 2:
@LCL
D=M
@2
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 3:
@LCL
D=M
@3
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.multiply:
@Main.main$ret.2
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.multiply
0;JMP
(Main.main$ret.2)
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 4:
@LCL
D=M
@4
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 5:
@LCL
D=M
@5
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.multiply:
@Main.main$ret.3
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.multiply
0;JMP
(Main.main$ret.3)
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP local 7:
@LCL
D=M
@7
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 5:
@LCL
D=M
@5
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.divide:
@Main.main$ret.4
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.divide
0;JMP
(Main.main$ret.4)
// C_PUSH local 4:
@LCL
D=M
@4
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.divide:
@Main.main$ret.5
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.divide
0;JMP
(Main.main$ret.5)
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Math.divide:
@Main.main$ret.6
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.divide
0;JMP
(Main.main$ret.6)
// C_POP local 8:
@LCL
D=M
@8
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 5000:
@5000
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 6:
@LCL
D=M
@6
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Memory.poke:
@Main.main$ret.7
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Memory.poke
0;JMP
(Main.main$ret.7)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 5001:
@5001
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 7:
@LCL
D=M
@7
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Memory.poke:
@Main.main$ret.8
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Memory.poke
0;JMP
(Main.main$ret.8)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 5002:
@5002
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 8:
@LCL
D=M
@8
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// call Memory.poke:
@Main.main$ret.9
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@7
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Memory.poke
0;JMP
(Main.main$ret.9)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// return Main.main:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Sys.init:
(Sys.init)
// call Memory.init:
@Sys.init$ret.1
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@5
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Memory.init
0;JMP
(Sys.init$ret.1)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// call Math.init:
@Sys.init$ret.2
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@5
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Math.init
0;JMP
(Sys.init$ret.2)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// call Main.main:
@Sys.init$ret.3
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@5
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Main.main
0;JMP
(Sys.init$ret.3)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label WHILE_EXP0:
(Sys.init$WHILE_EXP0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// not
@SP
A=M-1
M=!M
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Sys.init$WHILE_END0
D;JNE
// goto WHILE_EXP0:
@Sys.init$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Sys.init$WHILE_END0)
// funciton Sys.halt:
(Sys.halt)
// label WHILE_EXP0:
(Sys.halt$WHILE_EXP0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// not
@SP
A=M-1
M=!M
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Sys.halt$WHILE_END0
D;JNE
// goto WHILE_EXP0:
@Sys.halt$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Sys.halt$WHILE_END0)
// funciton Sys.wait:
(Sys.wait)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE25
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE25
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL25
D;JLT
@R15
M=0
@END_BOOL25
0;JMP
(X_NEGATIVE_Y_POSITIVE25)
@R15
M=-1
@END_BOOL25
0;JMP
(Y_NEGATIVE25)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE25
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL25
0;JMP
(X_AND_Y_NEGATIVE25)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL25
D;JLT
@R15
M=0
@END_BOOL25
0;JMP
(END_BOOL25)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Sys.wait$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Sys.wait$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Sys.wait$IF_TRUE0)
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// call Sys.error:
@Sys.wait$ret.4
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Sys.error
0;JMP
(Sys.wait$ret.4)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Sys.wait$IF_FALSE0)
// label WHILE_EXP0:
(Sys.wait$WHILE_EXP0)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE26
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE26
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL26
D;JGT
@R15
M=0
@END_BOOL26
0;JMP
(X_NEGATIVE_Y_POSITIVE26)
@R15
M=0
@END_BOOL26
0;JMP
(Y_NEGATIVE26)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE26
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL26
0;JMP
(X_AND_Y_NEGATIVE26)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL26
D;JGT
@R15
M=0
@END_BOOL26
0;JMP
(END_BOOL26)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Sys.wait$WHILE_END0
D;JNE
// C_PUSH constant 50:
@50
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label WHILE_EXP1:
(Sys.wait$WHILE_EXP1)
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE27
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE27
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL27
D;JGT
@R15
M=0
@END_BOOL27
0;JMP
(X_NEGATIVE_Y_POSITIVE27)
@R15
M=0
@END_BOOL27
0;JMP
(Y_NEGATIVE27)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE27
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL27
0;JMP
(X_AND_Y_NEGATIVE27)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL27
D;JGT
@R15
M=0
@END_BOOL27
0;JMP
(END_BOOL27)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto WHILE_END1:
@SP
AM=M-1
D=M
@Sys.wait$WHILE_END1
D;JNE
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto WHILE_EXP1:
@Sys.wait$WHILE_EXP1
0;JMP
// label WHILE_END1:
(Sys.wait$WHILE_END1)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_POP argument 0:
@ARG
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto WHILE_EXP0:
@Sys.wait$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Sys.wait$WHILE_END0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// return Sys.wait:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Sys.error:
(Sys.error)
// label WHILE_EXP0:
(Sys.error$WHILE_EXP0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// not
@SP
A=M-1
M=!M
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Sys.error$WHILE_END0
D;JNE
// goto WHILE_EXP0:
@Sys.error$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Sys.error$WHILE_END0)
// funciton Memory.init:
(Memory.init)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP static 0:
@Memory.0
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 2048:
@2048
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Memory.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 14334:
@14334
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 2049:
@2049
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Memory.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 2050:
@2050
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// return Memory.init:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Memory.peek:
(Memory.peek)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Memory.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// return Memory.peek:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Memory.poke:
(Memory.poke)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH static 0:
@Memory.0
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH argument 1:
@ARG
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// return Memory.poke:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Memory.alloc:
(Memory.alloc)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE28
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE28
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL28
D;JLT
@R15
M=0
@END_BOOL28
0;JMP
(X_NEGATIVE_Y_POSITIVE28)
@R15
M=-1
@END_BOOL28
0;JMP
(Y_NEGATIVE28)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE28
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL28
0;JMP
(X_AND_Y_NEGATIVE28)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL28
D;JLT
@R15
M=0
@END_BOOL28
0;JMP
(END_BOOL28)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Memory.alloc$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Memory.alloc$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Memory.alloc$IF_TRUE0)
// C_PUSH constant 5:
@5
D=A
@SP
A=M
M=D
@SP
M=M+1
// call Sys.error:
@Memory.alloc$ret.1
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Sys.error
0;JMP
(Memory.alloc$ret.1)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE0:
(Memory.alloc$IF_FALSE0)
// C_PUSH constant 2048:
@2048
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 1:
@LCL
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label WHILE_EXP0:
(Memory.alloc$WHILE_EXP0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// lt
@SP
AM=M-1
D=M
@Y_NEGATIVE29
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE29
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL29
D;JLT
@R15
M=0
@END_BOOL29
0;JMP
(X_NEGATIVE_Y_POSITIVE29)
@R15
M=-1
@END_BOOL29
0;JMP
(Y_NEGATIVE29)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE29
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=0
@END_BOOL29
0;JMP
(X_AND_Y_NEGATIVE29)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL29
D;JLT
@R15
M=0
@END_BOOL29
0;JMP
(END_BOOL29)
@R15
D=M
@SP
A=M-1
M=D
// not
@SP
A=M-1
M=!M
// if goto WHILE_END0:
@SP
AM=M-1
D=M
@Memory.alloc$WHILE_END0
D;JNE
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 1:
@LCL
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto WHILE_EXP0:
@Memory.alloc$WHILE_EXP0
0;JMP
// label WHILE_END0:
(Memory.alloc$WHILE_END0)
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 16379:
@16379
D=A
@SP
A=M
M=D
@SP
M=M+1
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE30
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE30
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL30
D;JGT
@R15
M=0
@END_BOOL30
0;JMP
(X_NEGATIVE_Y_POSITIVE30)
@R15
M=0
@END_BOOL30
0;JMP
(Y_NEGATIVE30)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE30
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL30
0;JMP
(X_AND_Y_NEGATIVE30)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL30
D;JGT
@R15
M=0
@END_BOOL30
0;JMP
(END_BOOL30)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE1:
@SP
AM=M-1
D=M
@Memory.alloc$IF_TRUE1
D;JNE
// goto IF_FALSE1:
@Memory.alloc$IF_FALSE1
0;JMP
// label IF_TRUE1:
(Memory.alloc$IF_TRUE1)
// C_PUSH constant 6:
@6
D=A
@SP
A=M
M=D
@SP
M=M+1
// call Sys.error:
@Memory.alloc$ret.2
D=A
@SP
A=M
M=D
@SP
M=M+1
@LCL
D=M
@SP
A=M
M=D
@SP
M=M+1
@ARG
D=M
@SP
A=M
M=D
@SP
M=M+1
@THIS
D=M
@SP
A=M
M=D
@SP
M=M+1
@THAT
D=M
@SP
A=M
M=D
@SP
M=M+1
@6
D=A
@SP
D=M-D
@ARG
M=D
@SP
D=M
@LCL
M=D
@Sys.error
0;JMP
(Memory.alloc$ret.2)
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE1:
(Memory.alloc$IF_FALSE1)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// gt
@SP
AM=M-1
D=M
@Y_NEGATIVE31
D;JLT
@R14
M=D
@SP
A=M-1
D=M
@X_NEGATIVE_Y_POSITIVE31
D;JLT
// Handle the case where both are positive or zero:
@R14
D=D-M
@R15
M=-1
@END_BOOL31
D;JGT
@R15
M=0
@END_BOOL31
0;JMP
(X_NEGATIVE_Y_POSITIVE31)
@R15
M=0
@END_BOOL31
0;JMP
(Y_NEGATIVE31)
@R14
M=D
@SP
A=M-1
D=M
@X_AND_Y_NEGATIVE31
D;JLT
// Handle the case where x>=0 and y<0:
@R15
M=-1
@END_BOOL31
0;JMP
(X_AND_Y_NEGATIVE31)
// Handle the case where both negative:
@R14
D=D-M
@R15
M=-1
@END_BOOL31
D;JGT
@R15
M=0
@END_BOOL31
0;JMP
(END_BOOL31)
@R15
D=M
@SP
A=M-1
M=D
// if goto IF_TRUE2:
@SP
AM=M-1
D=M
@Memory.alloc$IF_TRUE2
D;JNE
// goto IF_FALSE2:
@Memory.alloc$IF_FALSE2
0;JMP
// label IF_TRUE2:
(Memory.alloc$IF_TRUE2)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// eq
@SP
AM=M-1
D=M
A=A-1
D=M-D
M=0
@NOT_EQUAL32
D;JNE
// Handle the equal case by setting -1 (true)
@SP
A=M-1
M=-1
(NOT_EQUAL32)
// if goto IF_TRUE3:
@SP
AM=M-1
D=M
@Memory.alloc$IF_TRUE3
D;JNE
// goto IF_FALSE3:
@Memory.alloc$IF_FALSE3
0;JMP
// label IF_TRUE3:
(Memory.alloc$IF_TRUE3)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 3:
@3
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 4:
@4
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto IF_END3:
@Memory.alloc$IF_END3
0;JMP
// label IF_FALSE3:
(Memory.alloc$IF_FALSE3)
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 3:
@3
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_END3:
(Memory.alloc$IF_END3)
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_FALSE2:
(Memory.alloc$IF_FALSE2)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// return Memory.alloc:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
// funciton Memory.deAlloc:
(Memory.deAlloc)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH argument 0:
@ARG
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_POP local 0:
@LCL
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP local 1:
@LCL
D=M
@1
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// eq
@SP
AM=M-1
D=M
A=A-1
D=M-D
M=0
@NOT_EQUAL33
D;JNE
// Handle the equal case by setting -1 (true)
@SP
A=M-1
M=-1
(NOT_EQUAL33)
// if goto IF_TRUE0:
@SP
AM=M-1
D=M
@Memory.deAlloc$IF_TRUE0
D;JNE
// goto IF_FALSE0:
@Memory.deAlloc$IF_FALSE0
0;JMP
// label IF_TRUE0:
(Memory.deAlloc$IF_TRUE0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto IF_END0:
@Memory.deAlloc$IF_END0
0;JMP
// label IF_FALSE0:
(Memory.deAlloc$IF_FALSE0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// sub
@SP
AM=M-1
D=M
A=A-1
M=M-D
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// eq
@SP
AM=M-1
D=M
A=A-1
D=M-D
M=0
@NOT_EQUAL34
D;JNE
// Handle the equal case by setting -1 (true)
@SP
A=M-1
M=-1
(NOT_EQUAL34)
// if goto IF_TRUE1:
@SP
AM=M-1
D=M
@Memory.deAlloc$IF_TRUE1
D;JNE
// goto IF_FALSE1:
@Memory.deAlloc$IF_FALSE1
0;JMP
// label IF_TRUE1:
(Memory.deAlloc$IF_TRUE1)
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH constant 2:
@2
D=A
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// goto IF_END1:
@Memory.deAlloc$IF_END1
0;JMP
// label IF_FALSE1:
(Memory.deAlloc$IF_FALSE1)
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 0:
@LCL
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_PUSH constant 1:
@1
D=A
@SP
A=M
M=D
@SP
M=M+1
// C_PUSH local 1:
@LCL
D=M
@1
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// add
@SP
AM=M-1
D=M
A=A-1
M=M+D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH that 0:
@THAT
D=M
@0
A=D+A
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP temp 0:
@5
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_POP pointer 1:
@THAT
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// C_PUSH temp 0:
@5
D=M
@SP
A=M
M=D
@SP
M=M+1
// C_POP that 0:
@THAT
D=M
@0
A=D+A
D=A
@R13
M=D
@SP
AM=M-1
D=M
@R13
A=M
M=D
// label IF_END1:
(Memory.deAlloc$IF_END1)
// label IF_END0:
(Memory.deAlloc$IF_END0)
// C_PUSH constant 0:
@0
D=A
@SP
A=M
M=D
@SP
M=M+1
// return Memory.deAlloc:
@LCL
D=M
@R14
M=D
@R14
D=M
@5
A=D-A
D=M
@R13
M=D
@SP
A=M-1
D=M
@ARG
A=M
M=D
@ARG
D=M+1
@SP
M=D
@R14
D=M
@1
A=D-A
D=M
@THAT
M=D
@R14
D=M
@2
A=D-A
D=M
@THIS
M=D
@R14
D=M
@3
A=D-A
D=M
@ARG
M=D
@R14
D=M
@4
A=D-A
D=M
@LCL
M=D
@R13
A=M
0;JMP
